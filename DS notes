Tree

1. Binary search tree
- can be O(n) if unbalanced
- other than that, it's O(log n) meaning that you don't traverse through the whole structure, you simply decide once on each level(depth)

**Divide and conquer : simply means that we don't look at every single node, instead we devide up and make decision on each node to go left or right

Balancing our tree
- in production we want balanced tree like AVL tree and Red black tree that automatically rebalances itself
- we won't have to implement this in interview, just mention it and tell why it's useful

resources:
https://www.cs.usfca.edu/~galles/visualization/AVLtree.html
https://medium.com/basecs/the-little-avl-tree-that-could-86a3cae410c7
https://www.cs.usfca.edu/~galles/visualization/RedBlack.html
https://medium.com/basecs/painting-nodes-black-with-red-black-trees-60eacb2be9a5

2. Heap(Binary Heap) - remember one thing, parent is always greater than children
lookup O(n) - searching is slow
insert O(log N)
delete O(log N)

lookup is O(n) because Heap is less ordered than BST where left and right had meaning(in Heap, left and right can be any value)
- Can be used anywhere where ordering is important, IT'S GREAT FOR COMPARATIVE OPERATION
- Binary Heap(only two children to a node)
- Max/Min Heap (root node has the largest/smallest value)

Binary Heap simply inserts from left to right

Binary Heap is useful for things like Priority Queuevvvvv
Q. What is Priority Queue?
A. It's not just a simple FIFO, every element has priorities and elements with higher priority is served first. Simply imagine airplane seats.
Since we know the order we just go from top to bottom and left to right and insert bunch of items. Like this, most of the time, insertion is really fast except for some cases where you get high priority item being inserted in the heap, then you have to re-balance it.

3. Trie(unlike binary tree it can have multiple children)
- specialized tree used in searching most often with texts(it tells you if a word or part of a word exists in a text)
*Prefix tree: when you search something on google, it tries and completes what you were searching(auto-suggestion)
-> benefits are time and space

search
O(length of the word)
- also good in space complexity(no duplicate keys) -> for storing n,o,t and n,e,w,s you need only one n


Graphs
- used a lot for real world modling
- has Nodes(Vertex) and Edges
- Tree is a type of Graph as well

- Directed & Undirected Graph
- Weighted and Unweighted Graph
- Cyclic, Acyclic Graph(vertices connected in a circular fashion): cyclic graph works well with weighted graphs because normally there's a way to get back to the vertex you left from.

three ways to represent graph
1. Edge List: simply a list of all the edges
2. Adjacency List: for each vertex, we store a list of which other vertices it's connected to
3. Adjacency Matrix: for each vertex, we store a list(length of all the vertices) that shows weight or simply 0 or 1 indicating whether it's connected to that specific vertex or not

Algorithm: recursion

1. find the base case
2. find the recursive case
3. get closer and closer to the answer
-> Anyway it's exponential time(2^n) why would I ever use this? -> you can optimize it with dp(memoization) to O(n)

*Anything you do with a recursion CAN be done iteratively
You can keep your code DRY(Do not Repeat Yourself), recursion could be better for readability, but it's not always the best approach(because it creates extra memory footprint-stack)

Andrei use recursion when he's working with ds that he doesn't know how deep they are.

Tail Call Optimization(it's in many languagues)
- in js(es6), you can do recursion without increasing the call stack
https://2ality.com/2015/06/tail-call-optimization.html

Recursion is useful in BFS + DFS(Searching) and in some cases in Sorting

**Rule: Every time you are using a tree or converting Something into a tree, consider recursion.
Divide and Conquer using Recursion
1. Divide a problem into a number of subproblems that are smaller instances of the same problem
2. Each instance of the subproblem is identical in nature
3. The solutions of each subproblem can be combined to solve the problem at hand
