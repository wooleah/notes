Why is OOP or FP paradigm good?
1. clear and understandable
2. easy to extend
3. easy to maintain
4. memory efficient
5. code is DRY


OOP thinks real world model as an object
- properties are the state of the object
- methods allow us to manipulate the state of the object

Two different OOP language
1. class based
2. prototype based

*quick note
past       -> now
procedural -> OOP 

1. Factory functions (functiont that creates objects)
- if we make millions of instances, same methods will get copied million times in memory

We can use prototypal inheritance to share same functionality in multiple instance -> BUT HOW?
- we can make global function object and store functions in there, and then create an instance with elfFactory() and attach some function to that instance property and call it -> BUT it feels like a lot of manual work
-> we can use Object.create()
*Object.create(object) method creates a new object, using an existing object as the prototype of the newly created object
-> meaning it creates prototype chain between object and new object created.

example)
const elfFuctions = {
  attack() {
    return `${this.name} attcks with ${this.weapon}`;
  }
}
function createElf(name, weapon) {
  let newElf = Object.create(elfFuctions)
  newElf.name = name;
  newElf.weapon = weapon;
  return newElf;
}

const peter = createElf('Peter', 'sword');
peter.attack();
-> this is the true form of prototypal inheritance and it's meant to be used like this. BUT it's not JS community standards

What people used before Object.create to follow OOP paradigm
- instead of Object.create, people used constructor functions

example)
function Elf(name, weapon) {
  this.name = name;
  this.weapon = weapon;
}
const peter = new Elf('Peter', 'sword'); // make it capitol letter to let other dev know that you need to call new to invoke this

-> new keyword automatically returns the object(Elf object in this case) and it creates the constructor function(runs the code and constructs elf function)
(without new keyword, we are not creating the object and not returning the object, and we're not assigning this to the object that calls that func)

constructor function creates a function that creates and returns a new object and modifies "this"(global -> calling object)
- and constructor function allows us to use new keyword to do all that
- when that function is created and called new EC is created(has this, arguments)
- constructor function is a function(callable object) so it has invokable code(), optional names and properties, and most importantly prototype!
-> this prototype in constructor function is shared through new instances created by the constructor function
-> newElfInstance.__proto__ === Elf.prototype (every function created has prototype, but only constructor function make use of it)
-> newElfInstance.prototype === undefined (because newElfInstance is an object created by constructor function, not a func)
(only functions have access to the prototype object)

BIG GOTCHA IN OOP(js)
this keyword in function inside of a method is window object

-> ANYWAY, using prototype in code is hard to understand(not pretty)


*something weird about JS(technically everything in js is an object)
var a = new Number(5) -> type is object
var b = 5 -> type is number, but has access to Number.prototype
(except for null and undefined, everything has constructor functions -> which allows our objects to access prototype)
-> when we assign a var in js, internally it constructs a number using constructor function


