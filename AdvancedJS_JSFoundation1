Questions
1. JS is a single threaded language that can be non-blocking?
 - single threaded -> one call stack only(only can do one thing at a time)
  -> pros: can avoid complicated scenarios that can happen in multi-threaded languages(deadlocks)
 - What if one item in call stack is a massive task?(takes really long time) -> then on a website user won't be able to do anything(other tasks are blocked from performing) -> ASYNC to the rescue! -> wrap that massive task in setTimeout and make it async
 -> In order to not block the thread, a task can be transformed to async
2. Stack overflow is when call stack gets too big and there's no more space in call stack


Brief history
- American engineer Brendan Eich, creator of JS made the first js engine spidermonkey(Firefox uses this).
In 2008, google made v8 with c++ to achieve better speed with their newly created Chrome browser and Google map

Standard(ECMAscript)
- tells engine creators how js should work and how it should be standardized

What is JS Engine?
- Allows cpu to understand JS and give commands to computer
- Composed of Parser(parse string), AST(abstract syntax tree)
- then Interpreter -> Profiler -> Compiler -> Optimized code
- or Interpreter -> Bytecode

Interpreter vs compiler(two ways to run js)
- Interpreter translates code line by line on the fly
- Compiler doesn't translate on the fly, it reads through the code then try to understand what it is. Then it'll change that code into a new language that does the same thing.
*All languagues will have to go through interpreter or compiler at one point
- Interpreter and Compiler are both compilers but Interpreter read code line by line on the fly(compiles code at runtime dynamically). And compiler does the translation before the code gets executed. So basically they both translate code into bytecode(actually all js engines will produce bytecode). They both will eventually compile the source code down to machine code.
https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/
- Interpreter is faster because there's no compilation step, problem is that is you run the same code over and over, it gets slower(no optimization).
- Compiler takes more time because of the necessary compilation step, and removes all duplicates while simplifying the code. Therefore code generated by compilers are more optimized(faster)

Babel + Typescript
- Babel is a Javascript compiler that takes your modern JS code and returns browser compatible JS (older JS code).
- Typescript is a superset of Javascript that compiles down to Javascript.
-> This is called Transpiling(not compiling), take on language and convert it to a different one

JIT compiler in V8 Engine
1. Interpreter in v8 engine is called Ignition: takes AST and spits out Bytecode(not as low as machine code, but it's a code that's able to be interpreted by the js engine to run our program)
2. Profiler(or monitor): watches our code as it runs and makes notes on how we can optimize our code(types, how many times it's running) passes some code to JIT Compiler.
- First it runs everything through the interpreter and watches. When the same line of code are run a few times, that segment of code is called warm. If it's run a lot, then it's called hot. When a function starts getting warm, JIT send it off to be compiled and store that compilation(each line of the function is compiled to a stub).
- Stubs are indexed by line number and var type. And when the monitor sees that execution hitting the same code again with the same var types, it'll just pull out its compiled version.
- When the part of the code is very hot -> monitor send it off to the optimizing compiler. Then it gets optimized and be stored.
3. Compiler(called Turbofan): It optimizes the passed off code(as it's running) to run it faster, and then replace slower section of the code to optimized code.
- It optimized the code when it's hot(because the code is already running a whole bunch of times, so it's worth taking some execution time to optimize the code)
- execution speed of js code will gradually improve over time

-> Now we can write optimized code that doesn't confuse the compiler(if it makes a mistake then it does deoptimization - takes really long time to complete).
https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/

Comparing Other Languages
Most computer will not understand bytecode, you need some kind of engine to translate this to machine code
** Is Javascript an interpreted language?
- Technically, it depends on the implementation. Because for example v8 runs js code with interpreter line by line at runtime, but then optimizes it with a profiler and compiler(JIT)

Different JS engines across the vast landscape of host environments.

Browsers: 
Mozilla  - SpiderMonkey
Chrome and recent Opera  - V8 Engine
Edge  - Chakra Engine
Apple Safari - JavaScriptCore

Server Apps
V8 (Node JS Runtime)
Desktop Apps
Electron - V8 (basically, powered by Node JS runtime under the hood + chromium for GUI)

Each js engine applies its own set of optimisation techniques. But they all implement JIT compilation techniques to make our code run faster.

Writing optimized code(help js engine to do it's job easily)
1. Be careful with eval(), arguments, for in, with, delete
- Inline caching, so if we pass object as an argument then compiler caches it and replace places that uses that object so when it runs a bunch of times, it doesn't need to look for those arguments every single time.
- Hidden classes: define all properties of a class in constructor or at least add properties in the same order. Because compiler won't know that two objects are the same hidden class types and deoptimize them
-> Write optimized, predictable code


JS has v8 engine - has two parts(Memory Heap, Call Stack) + JIT compiler
1. Memory Heap - variables and ds are allocated here in unorderly manner
2. Call Stack - where code is read & executed(LIFO)
- Call Stack only stores functions
- Stack overflow: the call stack is full
3. Garbage Collection - JS is garbage collected language
- when we finish calling the func and we don't need that object anymore , js engine freeze up this memory we no longer use and collects our garbage. So only the data that we still need remain intact in memory heap.
- In garbage collected language like js, GC freeze memory on the heap and prevents memory leaks(memory gets too big and reaches max size). It's automatic btw.
- So we don't have to worry about memory allocation and management? NO!! (In low level languages like C, you control memory allocation. It's dangerous but that's why it can be super fast and efficient)
- js uses mark and sweep algorithm to garbage collect(when nothing is referencing some data, it gets removed from the memory)
4. Memory Leak: there's a limited amount of memory, so if you make too many vars(that we don't use), then there will be unused memory all around the place -> That's why global var is bad!
4.1 Three common memory leaks(globar var, event listeners, setInterval): avoid global vars if possible, remove event listeners when not needed, know that referenced objects in setInterval will never be removed if interval is not cleared
- when an app runs on the background for a really long time, there could be memory leaks.


Single threaded
- Means that it only has one call stack, and only one thing can happen at a time(synchronous).
-> JS Engine is synchronous, but we're never just using JS Engine. We have JS Runtime and JS Engine is part of it.


JS Runtime
- Js is single threaded so it only has one call stack and one memory heap. Web browser is working on the background while synchronous js is running in js runtime. It uses web API to talk to js engine telling that it has some data js engine requested.

- Web API comes with the browser. All browsers have their own js engine implementation and js runtime that provide web api(Dom, settimeout, fetch, ...). Type window in console. That's web API(things browser provides that js can use). They are not native to js. So browsers use low level language on the background.

Web API: apis provided by Web browsers. asynchronous

When js engine doesn't recognize some function like settimeout in the callstack(cause at first it goes into the call stack) it tells web API to take care of it. And it starts doing it's job on the background. And when it's done it puts the data and callback in callback queue. Then when call stack becomes free, the event loop will ask js engine to add those callbacks to the call stack

Event loop constantly asks js engine "is the call stack empty?" Event loop only runs when call stack is empty and when the entire js file has been read(after running js file through at least once)
*Btw console log also get stacked in the call stack


NodeJs
JS code: musical notes
JS engine: Composer who can read musical notes and play music
JS runtime: the whole package, music and composer and everything
-> NodeJs is JS runtime

up to 2009 js was considered a toy language that can only run inside browser, but Ryan Dahl thought it would be great to run js outside the browser and created NodeJS(written in C++). It's a C++ program(node.exe) that provides something similar to JS runtime. Uses V8 engine to understand JS engine, but also uses LIBUV to create event loop.
- node has global instead of window
- non-blocking means that it passes async tasks to worker thread on the background
- traditionally we had to make one thread for each request, and if server threadpool is full then it can no longer send request, but in NodeJs you don't have that restriction(it passes that request to async loop)


*Exercise1-1(prevent stackoverflow) -> Helps you understand the general concept of JS runtime
const list = new Array(100000).join('1.1').split('.');

function removeItemsFromList() {
    var item = list.pop();

    if (item) {
      // setTimeout(removeItemsFromList, 0);
      removeItemsFromList();
    }
};
removeItemsFromList();

- before functions in call stack are executed, they have to be pushed in the call stack, and since there are too many of them it causes stack overflow(there's a limit to the call stack). By adding setTimeout, below happens.
1. removeItemsFromList -> list.pop() gets added to the call stack and list.pop() returns true
2. setTimeout gets added to the call stack and it calls Web API and setTimeout start running there on the background(timer is 0ms so callback get added to the callback queue right after)
3. js engine continues to run the function but there's nothing left so it pops removeItemsFromList as well and becomes empty
4. event loop checks the call stack and sees that it's empty and js code has been run for at least once, so it transfers callback(removeItemsFromList) to the call stack again. 
5. 1~4 repeats


*Exercise1-2. Guess the execution order
// a
setTimeout(()=>{console.log('1', 'is the loneliest number')}, 0)
// b
setTimeout(()=>{console.log('2', 'can be as bad as one')}, 10)
// c
Promise.resolve('hi').then((data)=> console.log('2', data))
// d
console.log('3','is a crowd')

Answer: d -> c -> a -> b
Why??
This is a common gotcha and it is related to the inner workings of Javascript.
Promises get resolved or rejected before any method from the Web API.
The reason why this is the case is, because promises run on there on queue which is called the job queue. The job queue has a higher priority than the callback queue which means, that code gets pushed to the callstack again with a higher priority.
The order in which code gets executed is the following

1. From callstack
2. From job queue through the callstack
3. Fram callback queue via the event loop through the callstack
