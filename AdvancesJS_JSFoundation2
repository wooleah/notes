Execution context - Whenever code is run in JS it runs in ec(TRUE)
When JS engine starts, global ec gets added to the call stack and then whenever the engine sees (), it adds another ec(of that function) to the call stack. And when all of the code runs, global ec gets popped from the callstack.


Lexical environment(scope, environment)
It is basically about where it is written. When compiler is doing lexical analysis, it means that it's checking where that code was written(what universe is it part of, considering each function makes it's own universe).
Check where did we write that function? and What part of universe is it? Is the function written in global scope? Or is it written inside of another function?

*Lexical === compile time(where is the code written), compiler and interpreter will know different things about that code
Example:
function findName() {
  function a() {
  }
}
function sayMyName() {
  function findName()
}
-> a() is lexically inside findName(), compilere knows where it was written and can decide where to put things, and what actions to take, what a() has access to in that universe.

In JS, everytime we write a new function, it creates a new world for us inside of that function. Everytime we add another function into the call stack we are in that world(planet), and we have different environment, information.
-> Execution context tells you which lexical environment is currently running. 
-> In JS our lexical scope(where function was written) determines our available variables. Not where the function is called(dynamic scope). So it doesn't matter that findName() was called inside sayMyName(), it's lexical environment is global because that's where it was written.



There are two phases in Global execution context: creation and execution phase
creation phase provides global object and this keyword, and does this thing called "hoisting"

Hoisting - behavior of moving the variables and function declarations to the top of their respective environment during compilation phase. Variables are partially hoisted and functions are hoisted
- JS engine sees your code and allocates memory during the creation phase before it executes it. It specifically checks for "var" and "function" keywords(should be the first thing it sees on that line): var moves to the top and gets assigned undefined, and also function gets move to the top
*note that let and const don't get hoisted
- It's not physically moving codes, JS engine checks through the codes and reserve memory for vars and functions.

In global execution context, during creation phase JS engine will reserve spots in the Memory Heap and during execution phase it references to those spots(but at the point vars are undefined).

// function declaration
function sing() {
  console.log('lalala')
}
// function expression
var sing2 = function() {
  console.log('hahaha');
}


Exercise1
var a = 1
var a = 2
-> during creation phase, var a gets hoisted and gets assigned undefined, and during execution phase it becomes 1 and 2, so final value is 2

But for function declaration something gets assigned in memory during creation phase
a();
function a() {
  console.log('hi');
}
function a() {
  console.log('bye');
}
First a gets written in memory and then second a overwrites it, so a() becomes bye
*Note that any time you call a function, there's execution context and creation phase and an execution phase, hoisting involved.

Exercise2. What would happen here?
var favouriteFood = "grapes";
var foodThoughts = function () {
     console.log("Original favourite food: " + favouriteFood);

     var favouriteFood = "sushi";

     console.log("New favourite food: " + favouriteFood);
};
foodThoughts();

- when compiler reaches foodThoughts() and sees pair of parenthesis, it creates execution context and during creation phase, hoisting happens and favouriteFood and foodThoughts becomes undefined, and during execution phase foodThoughts is assigned function(function expression) in memory. Then foodThoughts is called so that execution context goes into the call stack and creation phase for foodThoughts happens. so favouriteFood gets hoisted to the top of the function so it becomes undefined and during execution phase both console log runs and it prints undefined first, then favouriteFood gets sushi assigned in memory and then prints new favourite food: sushi

// P.s. when you change the 'var' to 'const' technically there is still hoisting happening. That is why you get a reference error instead of looking at the global favouriteFood variable. let and const hoist but you cannot access them before the actual declaration is evaluated at runtime. So the engine says, "ya there is a favouriteFood variable here but you can't access it yet"
-> let and const gets hoisted but they live in temporary dead zone. Variables which are defined with let or const are only available at the point of time when they are declared and never before.

As you can see, hoisting can be confusing, and unpredictable -> Don't use it. Use const, let, function expression


Function invocation / Arguments keyword
// function expression(defined at runtime, when we invoke the function)
var canada = () => {
  console.log('cold');
}

// function declaration(defined at compile/parse time: when compiler initially looks at the code and do hoisting and allocate memory)
function india() {
  console.log('warm');
}

*When function is invoked we create another execution context on top of our global execution context. In global ec we get global object and this keyword, but in function execution context we get "arguments" keyword(Yes we don't get the argument keyword in global execution context)

function marry(p1, p2) {
  // in here if you console log arguments -> {0: p1, 1: p2}
}

*How to help js engine optimize our code(one of that was to not use arguments)
- it's not an array and new es6 brought Array.from to change object into an array
- or you can use rest operator and do below

function marry(...args) {
  // parameters passed to this function can be accessed in an array form by args + rest operator
}

- If you look for arguments in a function with no parameters, it becomes an empty object {} -> each execution context creates new arguments keyword(and this keyword, and global ec creates this keyword and global object)



Variable environment(local env for other function ec in the call stack and global env for global ec in the call stack)
In ec, we have little space called variable env, this is where vars can live in this specific stack world. Of course all vars live in JS engine's memory heap. But they need to know how they relate to one another.
Because functions in call stack are like little planets they usually don't know about each other

exercise
function two() {
  var isValid; // 5. isValid is undefined in this execution context.
}

function one() {
  var isValid = true; // 3. this variable will be put into the new execution context. It's own variable environment
  two(); // 4. New execution context created.
}

var isValid = false; // 1. Global variable is created as undefined. Then during execution, it changes in memory to false.
one() // 2. New execution context is created on top of the stack.

call stack has [global(), one(), two()]
-> global variable environment has isValid=false, one, two
-> one ec has isValid = true
-> two ec has isValid = undefined


