Execution context - Whenever code is run in JS it runs in ec(TRUE)
When JS engine starts, global ec gets added to the call stack and then whenever the engine sees (), it adds another ec(of that function) to the call stack. And when all of the code runs, global ec gets popped from the callstack.


Lexical environment(scope, environment)
It is basically about where it is written. When compiler is doing lexical analysis, it means that it's checking where that code was written(what universe is it part of, considering each function makes it's own universe).
Check where did we write that function? and What part of universe is it? Is the function written in global scope? Or is it written inside of another function?

*Lexical === compile time(where is the code written), compiler and interpreter will know different things about that code
Example:
function findName() {
  function a() {
  }
}
function sayMyName() {
  function findName()
}
-> a() is lexically inside findName(), compilere knows where it was written and can decide where to put things, and what actions to take, what a() has access to in that universe.

In JS, everytime we write a new function, it creates a new world for us inside of that function. Everytime we add another function into the call stack we are in that world(planet), and we have different environment, information.
-> Execution context tells you which lexical environment is currently running. 
-> In JS our lexical scope(where function was written) determines our available variables. Not where the function is called(dynamic scope). So it doesn't matter that findName() was called inside sayMyName(), it's lexical environment is global because that's where it was written.



There are two phases in Global execution context: creation and execution phase
creation phase provides global object and this keyword, and does this thing called "hoisting"

Hoisting - behavior of moving the variables and function declarations to the top of their respective environment during compilation phase. Variables are partially hoisted and functions are hoisted
- JS engine sees your code and allocates memory during the creation phase before it executes it. It specifically checks for "var" and "function" keywords(should be the first thing it sees on that line): var moves to the top and gets assigned undefined, and also function gets move to the top
*note that let and const don't get hoisted
- It's not physically moving codes, JS engine checks through the codes and reserve memory for vars and functions.

In global execution context, during creation phase JS engine will reserve spots in the Memory Heap and during execution phase it references to those spots(but at the point vars are undefined).

// function declaration
function sing() {
  console.log('lalala')
}
// function expression
var sing2 = function() {
  console.log('hahaha');
}


Exercise1
var a = 1
var a = 2
-> during creation phase, var a gets hoisted and gets assigned undefined, and during execution phase it becomes 1 and 2, so final value is 2

But for function declaration something gets assigned in memory during creation phase
a();
function a() {
  console.log('hi');
}
function a() {
  console.log('bye');
}
First a gets written in memory and then second a overwrites it, so a() becomes bye
*Note that any time you call a function, there's execution context and creation phase and an execution phase, hoisting involved.

Exercise2. What would happen here?
var favouriteFood = "grapes";
var foodThoughts = function () {
     console.log("Original favourite food: " + favouriteFood);

     var favouriteFood = "sushi";

     console.log("New favourite food: " + favouriteFood);
};
foodThoughts();

- during creation phase, hoisting happens and favouriteFood and foodThoughts becomes undefined, and during execution phase foodThoughts is assigned function(function expression) in memory. Then foodThoughts is called so that execution context goes into the call stack and creation phase for foodThoughts happens. so favouriteFood gets hoisted to the top of the function so it becomes undefined and during execution phase both console log runs and it prints undefined first, then favouriteFood gets sushi assigned in memory and then prints new favourite food: sushi

// P.s. when you change the 'var' to 'const' technically there is still hoisting happening. That is why you get a reference error instead of looking at the global favouriteFood variable. let and const hoist but you cannot access them before the actual declaration is evaluated at runtime. So the engine says, "ya there is a favouriteFood variable here but you can't access it yet"
-> let and const gets hoisted but they live in temporary dead zone. Variables which are defined with let or const are only available at the point of time when they are declared and never before.

As you can see, hoisting can be confusing, and unpredictable -> Don't use it. Use const, let, function expression

