JS has v8 engine - has two parts(Memory Heap, Call Stack)
1. Memory Heap - memory is allocated here
 - Memory Leak: there's a limited amount of memory, so if you make too many vars(that we don't use), then there will be unused memory all around the place -> That's why global var is bad!
2. Call Stack - where code is read & executed(LIFO)

Questions
1. JS is a single threaded language that can be non-blocking?
 - single threaded -> one call stack only(only can do one thing at a time)
  -> pros: can avoid complicated scenarios that can happen in multi-threaded languages(deadlocks)
 - What if one item in call stack is a massive task?(takes really long time) -> then on a website user won't be able to do anything(other tasks are blocked from performing) -> ASYNC to the rescue! -> wrap that massive task in setTimeout and make it async
 -> In order to not block the thread, a task can be transformed to async
2. Stack overflow is when call stack gets too big and there's no more space in call stack


---

JS Run-Time Environment
On top of the engine, they have Web APIs(DOM-document, AJAX-XMLHttpRequest, Timeout-setTimeout), Callback Queue, and Event Loop

ex)
1) console.log(1);
2) setTimeout(() => console.log(2), 2000);
3) console.log(3);
-> 1 and 3 runs first, and after 2s when timer is done, Web API will give you a notice and say there's a callback, and callback of setTimeout will be added to the Callback Queue
-> Event Loop constantly checks if the Call stack is empty, and if it's empty then it checks the Callback Queue. It sees callback from setTimeout and moves it to the Call Stack


Section 2: JavaScript Foundation

Brief history
- American engineer Brendan Eich, creator of JS made the first js engine spidermonkey(Firefox uses this).
In 2008, google made v8 with c++ to achieve better speed with their newly created Chrome browser and Google map

Standard(ECMAscript)
- tells engine creators how js should work and how it should be standardized

What is JS Engine?
- Allows cpu to understand JS and give commands to computer
- Composed of Parser(parse string), AST(abstract syntax tree)
- then Interpreter -> Profiler -> Compiler -> Optimized code
- or Interpreter -> Bytecode

Interpreter vs compiler(two ways to run js)
- Interpreter translates code line by line on the fly
- Compiler doesn't translate on the fly, it reads through the code then try to understand what it is. Then it'll change that code into a new language that does the same thing.
*All languagues will have to go through interpreter or compiler at one point
- Interpreter and Compiler are both compilers but Interpreter read code line by line on the fly(compiles code at runtime dynamically). And compiler does the translation before the code gets executed. So basically they both translate code into bytecode(actually all js engines will produce bytecode). They both will eventually compile the source code down to machine code.
https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/
- Interpreter is faster because there's no compilation step, problem is that is you run the same code over and over, it gets slower(no optimization).
- Compiler takes more time because of the necessary compilation step, and removes all duplicates while simplifying the code. Therefore code generated by compilers are more optimized(faster)

Babel + Typescript
- Babel is a Javascript compiler that takes your modern JS code and returns browser compatible JS (older JS code).
- Typescript is a superset of Javascript that compiles down to Javascript.
-> This is called Transpiling(not compiling), take on language and convert it to a different one

JIT Compiler(Mixed interpreter + compiler) - V8 Engine
- Interpreter in v8 engine is called Ignition: takes AST and spits out Bytecode(not as low as machine code, but it's a code that's able to be interpreted by the js engine to run our program)
- Profiler(or monitor): watches our code as it runs and makes notes on how we can optimize our code(types, how many times it's running) passes some code to JIT Compiler.
- Compiler(JIT Compiler - called Turbofan): It optimizes the passed off code(as it's running) to run it faster, and then replace slower section of the code to optimized code.
- execution speed of js code will gradually improve over time

-> Now we can write optimized code that doesn't confuse the compiler(if it makes a mistake then it does deoptimization - takes really long time to complete).

Comparing Other Languages
Most computer will not understand bytecode, you need some kind of engine to translate this to machine code
** Is Javascript an interpreted language?
- Technically, it depends on the implementation. Because for example v8 runs js code with interpreter line by line at runtime, but then optimizes it with a profiler and compiler(JIT).

Different JS engines across the vast landscape of host environments.

Browsers: 
Mozilla  - SpiderMonkey
Chrome and recent Opera  - V8 Engine
Edge  - Chakra Engine
Apple Safari - JavaScriptCore

Server Apps
V8 (Node JS Runtime)
Desktop Apps
Electron - V8 (basically, powered by Node JS runtime under the hood + chromium for GUI)

Each js engine applies its own set of optimisation techniques. But they all implement JIT compilation techniques to make our code run faster.


