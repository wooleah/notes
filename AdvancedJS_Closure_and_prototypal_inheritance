When you add param in a function, it adds that variable in var env as if we declared it.

HOF - why is it useful?
- Higher Order Function is a **func that returns a func** or accepts a func as a parameter
1. we can give it the data
2. tell the func what to do when we invoke it
** ability to tell the func what to do during invocation

- HOF use the concepts of currying and currying use the concept of closure

Why is invoking a function directly inside our main function a bad idea?
- it created below side-effects
1. tight coupling between the two func(main func becomes impure)
2. part of main func has external dependency and it can be modified by other parts of your code, that creates side-effect
3. main func becomes less testable and more error-prone

example) creating multiplyBy func
// should return a func that accepts a num and multiply it by something it wants
const multiplyBy = (num1) => {
  return num2 => num1 * num2;
}
// I want a func that receives a number and multiply it with 2
const multiplyTwo = multiplyBy(2);
const multiplyByTen = multiplyBy(10);
console.log(multiplyTwo(4))
console.log(multiplyByTen(2))

or 

// each step shows you how you call the func
const multiplyBy = num1 => num2 => num1 * num2
console.log(multiplyBy(2)(5))


Closures
1. Functions are first class citizens that can be passed around like any other data (function being first class citizen)
2. Before we even run the code, js engine knows where we wrote our code and which variables each function has access to (lexical scope)
Combining 1 + 2 -> we get the super power of closures

- normally function gets popped off the call stack and variable environment gets removed and garbage collected.
BUT if inner function is referencing outer function variable, it gets store in separate space in memory heap(closure box)
- basically closure is lexical scoping(we have hidden [[scope]] property that creates scope chain and it tells us what we have access to)
-> JS engine has these scope that links between the functions even before we run the code
- this accessing parent function variables after settimeout thing works because closure values are not in the call stack var env, it's in the memory heap. That's why after EC gets popped off the stack, we still have access to closure.
- as mentioned above SETTIMEOUT() is part of web api, so it gets sent to web api and then gets put in the callback queue and when the call stack is empty, the event loop will push that into the stack AND it still has access to the var it was referencing from the parent function var env(that variable can even be a const, because by the time event loop pushes that function back into the call stack, this var is set)

So.. WHY is closure useful?
1. Memory effeciency
- you don't need to create & delete large objects, you need to return a function inside another function that returns reference to an object inside the function
2. Data encapsulation (hiding the information to prevent manipulation or access)
- return functions and properties of the function inside of an object to control how much you want to expose the functionalities.
-> PRINCIPLE OF LEAST PRIVILEGE(security principle of programming): you don't wanna give anybody access to your API, or you only want to expose some functionalities.

